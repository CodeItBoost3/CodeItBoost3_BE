generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}


//  테스트를 위한 임시 그룹
// model Group{ 
//   id Int      @id @default(autoincrement())
//   name String
//   userId Int

//   member User[]
//   posts Post[] @relation("GroupRelation")
// }


model User {
  id              Int      @id @default(autoincrement())
  role            Role     @default(USER)
  nickname        String
  password        String
  clientId        String   @unique @map("client_id")
  profileImageUrl String?  @map("profile_image_url")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  posts     Post[]   @relation("UserPosts") 
  scraps    Scrap[]
  comments     Comment[]
  commentLikes CommentLike[]
  notification Notification[]
  // 그룹 추가 시 주석 해제
  // groups Group[] 
}

model Post {
  postId       Int      @id @default(autoincrement())
  groupId      Int
  userId       Int  
  nickname     String
  title        String
  content      String
  imageUrl     String?
  location     String
  moment       DateTime
  isPublic     Boolean  @default(true)
  createdAt    DateTime @default(now())
  likeCount    Int      @default(0)
  commentCount Int      @default(0)
  tag          Json

  author       User     @relation("UserPosts", fields: [userId], references: [id], onDelete: Cascade)
  // 그룹 추가 시 주석 해제
  // group        Group    @relation("GroupRelation", fields: [groupId], references: [id], onDelete: Cascade) 
  comments     Comment[]
  scraps      Scrap[]
}

model Scrap {
  scrapId        Int      @id @default(autoincrement()) 
  userId    Int
  postId    Int
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [postId], onDelete: Cascade)

  @@unique([userId, postId])  // 같은 사용자가 같은 게시글을 두 번 스크랩할 수 없게 설정
}

model Comment {
  commentId Int      @id @default(autoincrement())
  content   String
  userId    Int
  postId    Int
  parentId  Int?
  nickname  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  likeCount Int      @default(0)

  user    User          @relation(fields: [userId], references: [id])
  post    Post          @relation(fields: [postId], references: [postId], onDelete: Cascade)
  parent  Comment?      @relation("CommentReplies", fields: [parentId], references: [commentId], onDelete: Cascade)
  replies Comment[]     @relation("CommentReplies")
  likes   CommentLike[]
}

model CommentLike {
  id        Int      @id @default(autoincrement())
  userId    Int
  commentId Int
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [commentId], onDelete: Cascade)

  @@unique([userId, commentId])
}

model Notification {
  id        Int @id @default(autoincrement())
  userId    Int
  messageId Int

  reciever User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  message  Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  isRead   Boolean @default(false) @map("is_read")

  @@unique([userId, messageId])
}

model Message {
  id        Int         @id @default(autoincrement())
  title     String
  type      MessageType
  postId    Int?        @map("post_id")
  commentId Int?        @map("comment_id")
  content   String
  createdAt DateTime    @default(now()) @map("created_at")

  notification Notification[]
}

enum Role {
  USER
  ADMIN
}

enum MessageType {
  POST
  COMMENT
}
