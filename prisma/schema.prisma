generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int      @id @default(autoincrement())
  role            Role     @default(USER)
  nickname        String
  password        String
  clientId        String   @unique @map("client_id")
  profileImageUrl String?  @map("profile_image_url")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  posts         Post[]         @relation("UserPosts")
  scraps        Scrap[]
  comments      Comment[]
  commentLikes  CommentLike[]
  notification  Notification[]
  joined_groups GroupMember[]
}

model Post {
  postId       Int      @id @default(autoincrement())
  groupId      Int
  userId       Int
  nickname     String
  title        String
  content      String
  imageUrl     String?
  location     String
  moment       DateTime
  createdAt    DateTime @default(now())
  likeCount    Int      @default(0)
  commentCount Int      @default(0)
  tag          Json

  author   User      @relation("UserPosts", fields: [userId], references: [id], onDelete: Cascade)
  group    Group     @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  comments Comment[]
  scraps   Scrap[]
}

model Scrap {
  scrapId   Int      @id @default(autoincrement())
  userId    Int
  postId    Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [postId], onDelete: Cascade)

  @@unique([userId, postId]) // 같은 사용자가 같은 게시글을 두 번 스크랩할 수 없게 설정
}

model Comment {
  commentId Int      @id @default(autoincrement())
  content   String
  userId    Int
  postId    Int
  parentId  Int?
  nickname  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  likeCount Int      @default(0)

  user    User          @relation(fields: [userId], references: [id])
  post    Post          @relation(fields: [postId], references: [postId], onDelete: Cascade)
  parent  Comment?      @relation("CommentReplies", fields: [parentId], references: [commentId], onDelete: Cascade)
  replies Comment[]     @relation("CommentReplies")
  likes   CommentLike[]
}

model CommentLike {
  id        Int      @id @default(autoincrement())
  userId    Int
  commentId Int
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [commentId], onDelete: Cascade)

  @@unique([userId, commentId])
}

model Notification {
  id        Int @id @default(autoincrement())
  userId    Int
  messageId Int

  reciever  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @map("created_at")
  isRead    Boolean  @default(false) @map("is_read")

  @@unique([userId, messageId])
}

model Message {
  id        Int         @id @default(autoincrement())
  title     String
  type      MessageType
  groupId   Int?        @map("group_id")
  postId    Int?        @map("post_id")
  commentId Int?        @map("comment_id")
  content   String
  createdAt DateTime    @default(now()) @map("created_at")

  notification Notification[]
}

model Group {
  groupId          Int      @id @default(autoincrement())
  groupName        String   @unique
  groupPassword    String?
  groupDescription String?
  groupLikeCount   Int      @default(0)
  isPublic         Boolean  @default(true)
  createdAt        DateTime @default(now())
  imageUrl         String?
  badgeCount       Int      @default(0)

  members    GroupMember[]
  posts      Post[]
  badges     Badge[]
  groupLikes GroupLike[]
}

model GroupLike {
  id        Int      @id @default(autoincrement())
  userId    Int
  groupId   Int
  createdAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [groupId])
}

model GroupMember {
  groupId  Int
  userId   Int
  role     GroupRole @default(MEMBER)
  joinedAt DateTime  @default(now())
  group    Group     @relation(fields: [groupId], references: [groupId])
  user     User      @relation(fields: [userId], references: [id])

  @@id([groupId, userId])
  @@index([userId], map: "GroupMember_userId_fkey")
}

enum GroupRole {
  MEMBER
  ADMIN
}

model Badge {
  badgeId   Int      @id @default(autoincrement())
  groupId   Int      @map("group_id")
  badgeName String   @map("badge_name") @db.VarChar(32)
  badgeType String   @map("badge_type")
  createdAt DateTime @default(now()) @map("created_at")

  group Group @relation(fields: [groupId], references: [groupId], onDelete: Cascade)

  @@unique([groupId, badgeType])
  @@map("badge")
}

enum Role {
  USER
  ADMIN
}

enum MessageType {
  COMMENT_CREATED
  REPLY_CREATED
}
